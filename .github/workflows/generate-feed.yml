name: Update feeds

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  workflow_dispatch:
    inputs:
      use_prerelease:
        description: "Use prerelease"
        required: false
        type: boolean
        default: false
  push:
    paths:
      - "**/generate-feed.yml"
      - "**/podcasts.json"
      - "site/**"
  schedule:
    - cron: "0 * * * *"

jobs:
  update-and-deploy-feeds:
    name: "Update and deploy feeds"
    runs-on: ubuntu-24.04-arm
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    permissions:
      pages: write
      id-token: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Download latest release
        env:
          GH_TOKEN: ${{ github.token }}
          USE_PRERELEASE: ${{ github.event.inputs.use_prerelease || 'false' }}
        shell: pwsh
        run: |
          Write-Host "Determining platform..."
          $platform = switch ("${{ runner.os }}") {
            "Linux" {
              if ("${{ runner.arch }}" -eq "ARM64") { "linux-arm64" } else { "linux-x64" }
            }
            "Windows" { "win-x64" }
            "macOS" { "osx-arm64" }
            default {
              Write-Error "Unsupported platform: ${{ runner.os }}"
              exit 1
            }
          }
          Write-Host "Detected platform: $platform"

          Write-Host "Determining release type..."
          $releaseFlag = if ($env:USE_PRERELEASE -eq "true") {
            Write-Host "Using prerelease"
          } else {
            Write-Host "Using latest stable release"
            "--exclude-pre-releases"
          }

          Write-Host "Getting latest release for $platform..."
          $releaseInfo = if ($releaseFlag) {
            gh release list --repo ${{ github.repository }} $releaseFlag --limit 1 --json tagName
          } else {
            gh release list --repo ${{ github.repository }} --limit 1 --json tagName
          }

          $releases = $releaseInfo | ConvertFrom-Json
          if (-not $releases -or $releases.Count -eq 0) {
            Write-Error "No releases found. Please create a release first."
            exit 1
          }
          $tagName = $releases[0].tagName

          Write-Host "Found release: $tagName"

          # Download the platform-specific asset
          $assetName = switch ($platform) {
            "linux-x64" { "DrPodcast-linux-x64" }
            "linux-arm64" { "DrPodcast-linux-arm64" }
            "win-x64" { "DrPodcast-win-x64.exe" }
            "osx-arm64" { "DrPodcast-osx-arm64" }
          }
          Write-Host "Downloading asset: $assetName"
          gh release download $tagName --repo ${{ github.repository }} --pattern "$assetName"

          # Prepare executable
          if ("${{ runner.os }}" -eq "Windows") {
            # Rename Windows executable to standard name
            Rename-Item -Path $assetName -NewName "DrPodcast.exe"      
          } else {
            # Rename and make executable for Unix systems
            Rename-Item -Path $assetName -NewName "DrPodcast"
            chmod +x DrPodcast
          }

          Write-Host "Downloaded and prepared release executable for $platform"

      - name: Run feed generator
        env:
          API_KEY: ${{ secrets.API_KEY }}
          BASE_URL: ${{ secrets.BASE_URL }}
        shell: pwsh
        run: |
          if ("${{ runner.os }}" -eq "Windows") {
            & ./DrPodcast.exe --podcasts podcasts.json
          } else {
            & ./DrPodcast --podcasts podcasts.json
          }

      - name: Copy site files
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Path "output/_site" -Force
          New-Item -ItemType Directory -Path "output/_site/feeds" -Force
          Copy-Item -Path "site/*" -Destination "output/_site/" -Recurse -Force
          Copy-Item -Path "output/*.xml" -Destination "output/_site/feeds/" -Force

      - name: Generate feed statistics
        shell: bash
        run: |
          echo "## Feed Generation Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Feed | Episodes | Size | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|------|----------|------|--------|" >> $GITHUB_STEP_SUMMARY

          for feed in output/_site/feeds/*.xml; do
            if [ -f "$feed" ]; then
              filename=$(basename "$feed")
              episodes=$(grep -c "<item>" "$feed" || echo "0")
              size=$(du -h "$feed" | cut -f1)
              echo "| $filename | $episodes | $size | âœ“ |" >> $GITHUB_STEP_SUMMARY
            fi
          done

          echo "" >> $GITHUB_STEP_SUMMARY
          total_feeds=$(ls -1 output/_site/feeds/*.xml 2>/dev/null | wc -l)
          echo "**Total feeds generated:** $total_feeds" >> $GITHUB_STEP_SUMMARY
          echo "**Generation time:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY

      - name: Upload generated feeds as artifacts
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: generated-feeds-${{ github.run_id }}
          path: output/_site/feeds/*.xml
          retention-days: 7

      - name: Check for deployment changes
        id: deployment_check
        env:
          GH_TOKEN: ${{ github.token }}
        shell: pwsh
        run: |
          $siteUrl = gh api "repos/$env:GITHUB_REPOSITORY/pages" --jq '.html_url'
          $needsDeploy = $false

          # Check each feed for changes
          $feeds = Get-ChildItem -Path "output/_site/feeds/*.xml"
          foreach ($feed in $feeds) {
            $filename = $feed.Name
            
            # Get current hash
            $currentHash = (Get-FileHash -Path $feed.FullName -Algorithm SHA256).Hash.ToLower()
            
            # Try to get deployed file hash
            try {
              $deployedContent = Invoke-WebRequest -Uri "${siteUrl}feeds/$filename" -TimeoutSec 10 -ErrorAction Stop
              $deployedHash = (Get-FileHash -InputStream ([System.IO.MemoryStream]::new([System.Text.Encoding]::UTF8.GetBytes($deployedContent.Content))) -Algorithm SHA256).Hash.ToLower()
            } catch {
              $deployedHash = "none"
            }
            
            Write-Host "Checking $filename"
            Write-Host "Current hash: $currentHash"
            Write-Host "Deployed hash: $deployedHash"
            
            if ($currentHash -ne $deployedHash) {
              Write-Host "Changes detected in $filename"
              $needsDeploy = $true
              break
            }
          }

          if (-not $needsDeploy) {
            # Check if number of files changed
            try {
              $liveContent = Invoke-WebRequest -Uri $siteUrl -TimeoutSec 10 -ErrorAction Stop
              $liveCount = ([regex]::Matches($liveContent.Content, "class='feed-link'")).Count
            } catch {
              $liveCount = 0
            }
            $currentCount = (Get-ChildItem -Path "output/_site/feeds" -Filter "*.xml" -ErrorAction SilentlyContinue).Count
            
            if ($currentCount -ne $liveCount) {
              Write-Host "Number of XML files changed (current: $currentCount, live: $liveCount)"
              $needsDeploy = $true
            }
          }

          "needs_deploy=$needsDeploy" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Generate index.html
        if: steps.deployment_check.outputs.needs_deploy == 'true'
        shell: pwsh
        run: |
          # Get current timestamp in ISO 8601 format
          $currentTime = (Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ")

          # Generate feeds HTML
          $feedsHtml = ""
          $feeds = Get-ChildItem -Path "output/_site/feeds/*.xml"
          foreach ($feed in $feeds) {
            $filename = [System.IO.Path]::GetFileNameWithoutExtension($feed.Name)
            
            # Extract RSS feed content
            $content = Get-Content -Path $feed.FullName -Raw
            
            # Extract title from RSS feed and remove "(Reproduceret feed)" suffix
            $titleMatch = [regex]::Match($content, '<title>([^<]+)</title>')
            $title = if ($titleMatch.Success) {
              $extractedTitle = $titleMatch.Groups[1].Value
              # Remove "(Reproduceret feed)" or similar patterns in parentheses at the end
              $cleanTitle = $extractedTitle -replace '\s*\([^)]*feed[^)]*\)\s*$', ''
              $cleanTitle.Trim()
            } else {
              # Fallback to filename formatting if title extraction fails
              $filename -replace '-', ' '
            }
            
            # Extract image URL from the RSS feed's itunes:image element
            $imageMatch = [regex]::Match($content, '<itunes:image[^>]*href="([^"]*)"')
            $imageUrl = if ($imageMatch.Success) { $imageMatch.Groups[1].Value } else { "" }
            
            if ($imageUrl) {
              $feedsHtml += "<li><a class='feed-link' href='feeds/$filename.xml'><img class='feed-icon' src='$imageUrl' loading='lazy' alt='$title'><span class='feed-title'>$title</span></a></li>"
            } else {
              $feedsHtml += "<li><a class='feed-link' href='feeds/$filename.xml'><div class='feed-icon'></div><span class='feed-title'>$title</span></a></li>"
            }
          }

          # Read the index.html file
          $indexContent = Get-Content -Path "output/_site/index.html" -Raw

          # Insert deployment timestamp meta tag after opening head tag
          $indexContent = $indexContent -replace '(<head>)', "`$1`n    <meta name=`"deployment-time`" content=`"$currentTime`">"

          # Replace entire section between markers with generated feeds
          $indexContent = $indexContent -replace '(?s)<!-- BEGIN_FEEDS -->.*?<!-- END_FEEDS -->', "<!-- BEGIN_FEEDS -->`n        $feedsHtml`n        <!-- END_FEEDS -->"

          # Write back to file
          $indexContent | Set-Content -Path "output/_site/index.html" -NoNewline

      - name: Setup Pages
        if: steps.deployment_check.outputs.needs_deploy == 'true'
        uses: actions/configure-pages@v5

      - name: Upload Pages artifact
        if: steps.deployment_check.outputs.needs_deploy == 'true'
        uses: actions/upload-pages-artifact@v4
        with:
          path: output/_site

      - name: Deploy to GitHub Pages
        if: steps.deployment_check.outputs.needs_deploy == 'true'
        id: deployment
        uses: actions/deploy-pages@v4
